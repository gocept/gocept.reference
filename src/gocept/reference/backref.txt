===============
Back-references
===============

Simple back-references
======================

For working with references you have to have a located site set:

>>> import zope.site.hooks
>>> root = getRootFolder()
>>> zope.site.hooks.setSite(root)

For demonstration purposes we define two classes, one for referenced objects,
the other defining the reference. Classes using references have to implement
IAttributeAnnotatable as references are stored as annotations:

>>> from zope.container.contained import Contained
>>> import gocept.reference
>>> import zope.interface
>>> from zope.annotation.interfaces import IAttributeAnnotatable

>>> class Man(Contained):
...     zope.interface.implements(IAttributeAnnotatable)
...     wife = gocept.reference.Reference(back_reference='marriage')

>>> class Woman(Contained):
...     zope.interface.implements(IAttributeAnnotatable)
...     husband = gocept.reference.Reference(back_reference='marriage')

As instances of classes defined in a doctest cannot be made persistent, we
import implementations of the classes from a real Python module:

>>> from gocept.reference.testing import Man, Woman

The referenced objects must be stored in the ZODB and must be located:

>>> john = root['john'] = Man()
>>> jane = root['jane'] = Woman()

In order to establish a pair of reference and back-reference, it is sufficient
to assign one of the two objects in question to the reference attribute:

>>> john.wife = jane
>>> john.wife is jane
True
>>> jane.husband is john
True

Back-references will be kept consistent when changing one of the two
references:

>>> lilly = root['lilly'] = Woman()
>>> john.wife = lilly
>>> john.wife is lilly
True
>>> lilly.husband is john
True
>>> jane.husband is None
True

This also works if one of the two references is changed implicitly by the
back-reference mechanism:

>>> jane.husband = john
>>> jane.husband is john
True
>>> john.wife is jane
True
>>> lilly.husband is None
True

If a back-reference attribute is set to None, the back-reference on the
previously set reference target is set to None as well:

>>> john.wife = None
>>> john.wife is None
True
>>> jane.husband is None
True


Back-references involving reference collections (one-to-many)
=============================================================

Let's define two more sample classes, instances of one of which reference a
collection of instances of the other:

>>> class Parent(Contained):
...     zope.interface.implements(IAttributeAnnotatable)
...     children = gocept.reference.ReferenceCollection(
...         back_reference='parent-child')
...     def __init__(self):
...         self.children = set()


>>> class Child(Contained):
...     zope.interface.implements(IAttributeAnnotatable)
...     parent = gocept.reference.Reference(back_reference='parent-child')

>>> from gocept.reference.testing import Parent, Child

We need located instances of these classes again:

>>> homer = root['homer'] = Parent()
>>> bart = root['bart'] = Child()

Adding bart to homer's children makes bart reference homer as his parent:

>>> homer.children.add(bart)
>>> homer.children
InstrumentedSet([u'/bart'])
>>> bart in homer.children
True
>>> bart.parent is homer
True

Removing bart from homer's children again will reset bart's parent:

>>> homer.children.remove(bart)
>>> homer.children
InstrumentedSet([])
>>> bart.parent

The same referencing and dereferencing can be achieved by setting and
unsetting bart's parent:

>>> bart.parent = homer
>>> homer.children
InstrumentedSet([u'/bart'])
>>> bart in homer.children
True
>>> bart.parent is homer
True

>>> bart.parent = None
>>> homer.children
InstrumentedSet([])
>>> bart.parent


.. Local Variables:
.. mode: rst
.. End:
